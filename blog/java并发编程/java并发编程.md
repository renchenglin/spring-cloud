# 线程安全问题
	个人理解：多个线程在cpu的调度下，同时对共享数据的非原子写操作，导致最终不可预料的行为即为线程安全问题。
	也就是说，多个线程间没有共享数据，也就不存在线程安全问题。
	也就是说，多个线程间有共享数据，但是对共享数据只是读操作，也不存在线程安全问题。
	也就是说，多个线程间有共享数据，也有写操作，但是写操作是操作系统指令级的原子操作，也不存在线程安全问题。
	
## 为什么存在线程安全问题

	发生线程安全问题的本质体现在java的内存模型上，java的内存模型分为主内存和工作内存。
	jvm内存
		主内存
			堆
			方法区
		工作内存
			栈
			寄存器
		工作内存
			栈
			寄存器
	
	其中主内存为共享区，工作内存为线程独有的区域，线程之间无法直接访问对方的工作内存，如果要发生数据交换，则必须经过主内存进行中转。
	划分为此种模式是为了提供运行速度。
	工作过程中，先将共享数据拷贝到工作内存，在工作内存中完成对共享数据的操作，最后写回主内存区。
	为此，JVM规范定义了线程对内存间交互操作
	Lock(锁定)：作用于主内存中的变量，把一个变量标识为一条线程独占的状态。
	Read(读取)：作用于主内存中的变量，把一个变量的值从主内存传输到线程的工作内存中。
	Load(加载)：作用于工作内存中的变量，把read操作从主内存中得到的变量的值放入工作内存的变量副本中。
	Use(使用)：作用于工作内存中的变量，把工作内存中一个变量的值传递给执行引擎。
	Assign(赋值)：作用于工作内存中的变量，把一个从执行引擎接收到的值赋值给工作内存中的变量。
	Store(存储)：作用于工作内存中的变量，把工作内存中的一个变量的值传送到主内存中。
	Write(写入)：作用于主内存中的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。
	Unlock(解锁)：作用于主内存中的变量，把一个处于锁定状态的变量释放出来，之后可被其它线程锁定。
	
	由于read and load、use、assign、store and write在多个线程之间的执行是无序的
	并且在模型上是线程各自操作各自的工作内存区，导致在同步回主内存区时发生了不可预料的行为，这个是导致线程安全的根本原因。
	
## 如何解决线程安全问题

*	共享性：消除变量的共享性
*	互斥性：读写互斥，如果所有线程没有写的行为，也就不存在线程安全问题。
*	可见性：保证共享变量对所有线程是可见的，即对共享变量的写操作立即写入主内存，对其他线程可见，java的volatile即是解决了可见性。
*	原子性：写操作是一个原子操作，如this.a = a;即为一个原子操作;i++则不是一个原子操作。
*	有序性：多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程，线程在引用变量时不能直接从主内存中引用,如果线程工作内存中没有该变量,则会从主内存中拷贝一个副本到工作内存中,这个过程为read-load,完成后线程会引用该副本，线程不能直接为主存中中字段赋值，它会将值指定给工作内存中的变量副本(assign),完成后这个变量副本会同步到主存储区(store-write)，至于何时同步过去，根据JVM实现系统决定。保证cpu在调度线程时，对共享变量的操作是有序的。

# volatile
	volatile是java提供的一种同步手段，只不过它是轻量级的同步，为什么这么说，
	因为volatile只能保证多线程的内存可见性，不能保证多线程的执行有序性。
	而最彻底的同步要保证有序性和可见性，例如synchronized。
	任何被volatile修饰的变量，都不拷贝副本到工作内存，任何修改都及时写在主存。
	因此对于Valatile修饰的变量的修改，所有线程马上就能看到，但是volatile不能保证对变量的修改是有序的
	
	volatile不能保证线程安全问题，
public class Test{  
  public volatile int a;  
  public void add(int count){  
       a=a+count;  
  }  
  public void setA(int a){  
      this.a=a;  
  }  
} 	
	setA是线程安全的，而add则不是线程安全的。
	
# synchronized
	java用synchronized关键字做为多线程并发环境的执行有序性的保证手段之一。
	当一段代码会修改共享变量，这一段代码成为互斥区或临界区，为了保证共享变量的正确性，synchronized标示了临界区。
	
## 锁对象

*	理论上，每个对象都可以做为锁，但一个对象做为锁时，应该被多个线程共享，这样才显得有意义，在并发环境下，一个没有共享的对象作为锁是没有意义的。
*	每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个被线程被唤醒(notify)后，才会进入到就绪队列，等待cpu的调度。
*	每个锁对象有一个monitor对象，
*	synchronized锁是悲观锁。

## 线程执行临界区代码过程
	synchronized既保证了cpu调度线程的有序性，也保证了共享变量的可见性，所以可以保证线程安全问题。
*	1.获得同步锁
*	2.清空工作内存
*	3.从主存拷贝变量副本到工作内存
*	4.对这些变量计算
*	5.将变量从工作内存写回到主存
*	6.释放锁

## synchronized锁的获取过程

*	1、线程1执行到同步块时，会进行锁的竞争，如果竞争到锁，则进入同步块中执行
*	2、如果没有竞争到锁，则会进入自旋，继续进行锁的竞争，在自旋周期内，竞争到锁（占用锁的线程释放锁并且线程1竞争到锁），执行同步块
*	3、自旋周期内没有竞争到锁，则进入contentionList队列，进行排队
*	4、占用锁的线程释放锁时，会将一部分contentionList队列中的线程移动到entryList队列中，并唤醒waitSet中的线程
*	5、下一轮的线程竞争由onDeck主持，竞争到锁的进入同步块的执行。

## 非公平锁
	对于运行中执行到同步块触发锁竞争，使用自旋的方式进行竞争，对于正在队列中的线程和正在竞争的线程是不公平的，所以自旋锁是非公平锁

# 锁的性能
	前面介绍了synchronized可以解决线程安全问题，即解决了可见性问题、有序性问题。
	但是synchronized是依赖操作系统底层的mutex lock锁进行的。
	在多线程锁竞争情况在，没有获取到锁的线程会进入阻塞状态，获取到锁的线程会进入运行状态，操作系统完成线程的切换，系统内核会进行用户态到内核态到用户态的切换。
	这种切换代价非常大，会导致程序的性能急剧下降。为了解决这个问题，jdk在1.6对synchronized进行了优化。
	引入了偏向锁、轻量级锁、重量级锁的概念。
	
## mark word
	对象实例由对象头、实例数据组成。其中mark word就在对象头部
	32位的jvm虚拟机的mark word结构如下，其中最后2位是锁标志，后第3位是偏向锁标志
	
	锁状态		25bit			4bit		1bit		2bit
			23bit		2bit				是否偏向锁		锁标志位
	无锁状态	对象的hashCode		对象分代年龄	0			01
	偏向锁	线程ID		Epoch	对象分代年龄	1			01
	轻量级锁	指向栈中锁记录的指针								00
	重量级锁	指向互斥量（重量级锁）的指针							10
	GC标记	空											11
## 获取锁的整个过程
	

	