# 消息中间件

*	平台无关性

*	解耦：消息中间件在处理过程中插入了一个隐含的、基于数据的接口层，两边的处理过程都要基于这一接口，这允许独立的修改或者扩展两边的接口，只要确保都遵循同样的接口规范即可。

*	冗余（存储）：有些情况下，处理数据的过程会失败。消息中间件提供了持久化直至数据被完全处理，规避了数据丢失的风险。

*	扩展性：

*	削峰：在访问量剧增的情况下，消息中间件能够使关键组件支撑突发的访问压力。突发的访问压力并不常见，对于投入资源无疑是巨大的浪费。

*	队列：在一定程度上可以保证顺序。

*	异步通信：消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理，在之后的时间进行慢慢处理。


# RabbitMQ
	
## 队列（Queue）

*	在rabbitmq中的内部对象，用于存储消息，生产者产生的消息最终投递到队列中。
*	消费者只能从队列中获取消息
*	多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（rount-robbin,轮询）
*	队列不支持广播

## 交换器（Exchange）

*	生产者的消息最先到达交换器，由交换机进行消息路由，转发到队列中（如果路由不到则丢弃或者返回给生产者，具体见mandatory的配置）
*	交换器有四种类型（fanout、direct、topic、headers）

## 路由键（RoutingKey）

*	生产者将消息发给交换器时，需要指定一个 RoutingKey，用来指定消息的路由规则

## 绑定（Bingding）

*	交换器和队列通过绑定进行关联，指定交换器与队列的联系关系
*	交换器的路由转发由交换器的模式、消息指定的路由键、交换器的绑定三者决定的
*	对于topic类型的交换器，RoutingKey与BindingKey之间需要做模糊匹配

## 交换器类型

*	fanout:将发往该交换器的消息路由到所有绑定到该交换器的队列中，也就是说此时RoutingKey失效。
*	direct:将发往该交换器的消息路由到绑定到该交换器中BindingKey与消息的RoutingKey完全一致的队列中
*	topic:将消息路由到RoutingKey与BindingKey相匹配的队列中，可以使用*或者#进行模糊匹配，即将一个路由键路由到
多个队列中
*	headers:headers类型的交换器不依赖于路由键的匹配，而是根据发送的消息内容中的headers属性进行完全匹配，headers性能很差，而且也不实用，现在基本不用了。


# 消费消息的两种模式

*	推模式

*	拉模式


# mandatory

*	当mandatory设置为true时，交换器无法根据自身类型和路由键找到一个符合条件的队列时，会调用Basic.Return命令将消息返回给生产者。
*	当mandatory设置为false时，交换器无法根据自身类型和路由键找到一个符合条件的队列时，直接将消息丢弃

*	immediate：immediate是与mandatory一级的参数，3.0版本已经被启用，改用TTL和DLX的方法替代


# TTL
	Time To Live,即过期时间。

*	可以针对消息和队列两个维度设置过期时间。

*	通过队列设置TTL，针对的是队列中的所有消息，所有消息都有相同的TTL，消息过期会立即从队列中抹除（判断消息过期，每条消息都有相同的过期时间，只需要定期从头部扫描即可）
*	也可以在消息投递时设置消息的TTL，单位是毫秒，只有在投递之前，才能判断是过期消息（因为判断消息过期，需要扫描整个队列）
*	如果两种方式都设置，则以TTL较小的时间为准
*	TTL不设置，则表示消息永不过期
*	TTL设置为0，则表示具体立即投递消息的条件则会立即将消息投递给消费者，否则会立即被丢弃
*	队列的TTL不能设置为0

# DLX
	Dead-Letter-Exchange,死信交换器。队列中的消息会变为死信（Dead Message），变为死信之后，它能被重新发送到另一个交换器中，这个交换器就是DLX，与DLX绑定的队列为死信队列。

*	变为死信一般有几个情况：消息被拒绝，并且设置requeue为false；消息过期（TTL超时）；队列到达最大长度

# 延迟队列
	延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等到特定时间后，消费者才能拿到进行消费，如支付场景一般会有30min中的支付时间，30分钟不支付，则进入异常处理，在这个场景下，异常处理的消息即为延迟队列。

*	RabbitMQ不支持延迟队列，但是通过TTL和死信队列可以完成延迟队列的功能。

# 持久化
	持久化可以提高RabbitMQ的可靠性，以防在异常情况（重启、宕机、关闭等）下的数据丢失。

*	持久化分为三个部分：交换器持久化、队列持久化、消息持久化
*	申明队列时将durable设置为true，如果交换器不设置持久化，那么在rabbitmq重启时。相关的交换器的元数据会丢失，交换器无法进行路由
*	队列不设置持久化，重启时，队列的元数据会丢失，此时消息也会丢失。
*	队列的持久化只能保证队列的元数据，但是并不能保证内部存储的消息不会丢失，要确保消息不会丢失，则也必须将消息也设置为持久化
*	如果消费者在订阅消息将autoAck参数设置为true，当消费者接收到消息还没有来得及处理就宕机了，也会丢失消息。解决办法是autoAck设置为false










# 安装

```

docker pull rabbitmq:3.7.8-management
docker run -d --name rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3.7.8-management

运行容器
docker run -d  -p 5671:5671 -p 5672:5672  -p 15672:15672 -p 15671:15671  -p 25672:25672  -v /root/data/rabbitmq-data/:/var/rabbitmq/lib  --name rabbitmq rabbitmq:3.7.8-management

访问管理端
http://192.168.31.105:15672

进入容器
docker exec -it rabbitmq /bin/bash

```

